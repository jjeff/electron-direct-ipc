# EventMap and InvokeMap: Why `any` is the Correct Choice

## Summary

The `EventMap` and `InvokeMap` interfaces intentionally use `any` types in their generic constraints. This is not a compromise or oversight—it's the **correct and necessary** approach for proper TypeScript variance handling.

## The Interfaces

```typescript
export interface EventMap {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: (...args: any[]) => any
}

export interface InvokeMap {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: (...args: any[]) => Awaitable<any>
}
```

## Why Not `unknown[]`?

### The Problem with `unknown[]`

When we attempted to use `unknown[]` instead of `any[]`, TypeScript produced errors at type transformation sites:

```typescript
// This type transformation prepends a 'sender' parameter
type WithSender<T extends EventMap> = {
  [K in keyof T]: (
    sender: DirectIpcTarget,
    ...args: Parameters<T[K]>
  ) => ReturnType<T[K]>
}

// ERROR with unknown[] constraint:
// Type 'WithSender<TMessageMap>' does not satisfy constraint 'EventMap'
// Type '(sender: DirectIpcTarget, ...args: Parameters<...>) => ...'
//   is not assignable to type '(...args: unknown[]) => unknown'
```

### TypeScript Variance Rules

The issue stems from how TypeScript handles function parameter variance:

1. **Function parameters are contravariant**: A function expecting `Animal` can be safely used where a function expecting `Dog` is required (because `Dog` is more specific).

2. **Array types have mutable variance**: `unknown[]` cannot accept the more specific tuple type `[sender: DirectIpcTarget, ...args: T]` due to mutability concerns.

3. **`readonly unknown[]` also fails**: While readonly helps with some variance issues, it creates incompatibility with mutable tuple types that are generated by `Parameters<T>`.

## Why `any[]` Works

The `any` type has special bivariant behavior in TypeScript:

1. **Bidirectional Assignability**: Types can be assigned to and from `any` in both directions, which is exactly what's needed for a generic constraint.

2. **Inference Preservation**: When used in a constraint, `any` doesn't prevent type inference from flowing through. The actual type safety comes from the concrete generic parameter:

```typescript
type MyEventMap = {
  'user-updated': (userId: string, name: string) => void
}

// TypeScript infers TMessageMap = MyEventMap, not EventMap
const directIpc = DirectIpcRenderer.instance<MyEventMap>()

// Type safety is preserved at call sites
directIpc.on('user-updated', (sender, userId, name) => {
  // userId is known to be string
  // name is known to be string
})
```

3. **Constraint Satisfaction**: Types with named parameters like `(sender: DirectIpcTarget, userId: string) => void` can satisfy the `(...args: any[]) => any` constraint due to `any`'s special variance properties.

## The Role of Generic Constraints

It's important to understand what generic constraints are for:

- **Constraints establish a lower bound** on what operations are available on the generic type
- **They do NOT provide the actual type safety**—that comes from the concrete type parameter
- The constraint `T extends EventMap` means "T must have the structure of an EventMap", not "T is exactly an EventMap"

## Type Safety is Not Compromised

Despite using `any` in the constraint, full type safety is maintained:

```typescript
type MyEventMap = {
  'my-event': (count: number) => void
}

const directIpc = DirectIpcRenderer.instance<MyEventMap>()

// ✓ TypeScript enforces parameter types
directIpc.on('my-event', (sender, count: number) => {
  const x: number = count  // ✓ Type-safe
})

// ✗ TypeScript catches errors
directIpc.on('my-event', (sender, count: string) => {
  // ERROR: Type 'number' is not assignable to type 'string'
})
```

## Alternative Approaches Considered

### 1. Using `never`
```typescript
[key: string]: (...args: never) => unknown
```
**Result**: Failed because `never` is the bottom type—nothing can be assigned to it.

### 2. Using `unknown[]`
```typescript
[key: string]: (...args: unknown[]) => unknown
```
**Result**: Failed due to contravariance issues with transformed tuple types.

### 3. Using `readonly unknown[]`
```typescript
[key: string]: (...args: readonly unknown[]) => unknown
```
**Result**: Failed because readonly arrays are incompatible with mutable tuple types generated by `Parameters<T>`.

### 4. Complex Conditional Types
We could theoretically create highly complex conditional types to work around variance issues, but:
- This would make the code significantly harder to understand
- It would provide no additional type safety
- It would likely cause other inference issues

## Conclusion

**The use of `any` in `EventMap` and `InvokeMap` is the correct, idiomatic TypeScript solution** for generic function type constraints that need to:

1. Allow type transformations (like `WithSender<T>`)
2. Preserve type inference through generic parameters
3. Work with both named and rest parameters
4. Maintain full type safety at call sites

The ESLint warnings are properly suppressed with inline comments explaining this justification.

## References

- [TypeScript Handbook: Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
- [TypeScript Handbook: Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
- TypeScript Issue: Function parameter bivariance and any type behavior

## Test Coverage

The correctness of this approach is verified by:
- `tests/EventMap.variance.test.ts` - Tests variance behavior and type inference
- `tests/DirectIpcRenderer.types.ts` - Compile-time type tests
- All existing integration tests continue to pass with full type safety
